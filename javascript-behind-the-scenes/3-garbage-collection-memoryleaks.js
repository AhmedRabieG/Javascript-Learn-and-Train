
// garbage coollection هي عملية تلقائية في جافاسكريبت بتساعد في إدارة الذاكرة
// الهدف منها هو تحرير الذاكرة من الكائنات اللي مش محتاجها البرنامج بتاعي anymore
// وده بيتم عن طريق تتبع الكائنات اللي مش في استخدامها anymore وازالتها من الذاكرة

// جافاسكريبت بتستخدم خوارزمية اسمها "mark-and-sweep" في عملية ال garbage collection
// الخوارزمية دي بتشتغل عن طريق تتبع الكائنات اللي مش في استخدامها anymore
// وازالتها من الذاكرة

// مثال بسيط
let obj1 = { name: "object 1" };
let obj2 = { name: "object 2" };
let obj3 = { name: "object 3" };
obj1 = obj2;
obj2 = obj3;
obj3 = null;
console.log(obj1);

// في المثال عندي 3 كائنات obj1, obj2, obj3
// في البداية كل كائن منهم بيشير الي كائن مختلف في الذاكرة
// بعد كده قمت بتغيير المراجع بتاعتهم
// obj1 بقت تشير الي نفس الكائن اللي بيشير ليه obj2
// و obj2 بقت تشير الي نفس الكائن اللي بيشير ليه obj3
// و obj3 بقت null يعني مش بتشير لاي كائن   
// بعد التغييرات دي الكائن الاولاني اللي كان بيشير ليه obj1
// والكائن التاني اللي كان بيشير ليه obj2
// مبقوش ليهم اي مراجع بتشير ليهم في البرنامج بتاعي anymore
// فبالتالي هما بقى مش في استخدام anymore
// وده معناه ان ال garbage collector هيقوم بازالتهم من الذاكرة في وقت لاحق

// ايه هي ال memory leaks في جافاسكريبت ؟
// ال memory leaks هي حالة في البرنامج بتاعي بتستهلك فيها الذاكرة بشكل زائد
// وده بيحصل لما يكون في كائنات في الذاكرة مش في استخدامها anymore
// لكن لسه في مراجع بتشير ليهم في البرنامج بتاعي
// وده بيمنع ال garbage collector من ازالتهم من الذاكرة
// وده بيؤدي الي استهلاك زائد للذاكرة وبيسبب بطء في الاداء
// مثال علي memory leak



function createMemoryLeak() {
    let leakedArray = [];   
    for (let i = 0; i < 1000000; i++) {
        leakedArray.push(new Array(1000).fill(0));
    }
    return leakedArray;
}
let myLeak = createMemoryLeak();
// console.log("my Leak",myLeak);

// في المثال عندي دالة createMemoryLeak بتنشئ مصفوفة كبيرة جدا
// وبتملأها بكائنات جديدة   
// وبتشتغل عن طريق تتبع الكائنات اللي مش في استخدامها anymore
// وازالتها من الذاكرة  
// لما بنادي علي الدالة دي بتنشئ المصفوفة الكبيرة
// وبترجعلي المرجع بتاعها
// وبتبقى مش في استخدامها anymore
// وده معناه ان ال garbage collector هيقوم بازالته من الذاكرة في وقت لاحق
// لكن في الحالة دي انا مخزن المرجع بتاع المصفوفة في المتغير myLeak
// وده بيمنع ال garbage collector من ازالته من الذاكرة
// وده بيؤدي الي استهلاك زائد للذاكرة وبيسبب بطء في الاداء

// ازاي اتجنب ال memory leaks في جافاسكريبت ؟
// 1- اتجنب المراجع العالمية (global references)
// لانها بتفضل في الذاكرة طول ما البرنامج شغال
// وبتشتغل عن طريق تتبع الكائنات اللي مش في استخدامها anymore    
// وازالتها من الذاكرة
var one = { name: "i am global" };
var two = { name: "i am also global" };



// 2-  event listeners
// لانها بتفضل في الذاكرة طول ما البرنامج شغال
// وبتشتغل عن طريق تتبع الكائنات اللي مش في استخدامها anymore
// وازالتها من الذاكرة
// مثال
const button = document.createElement('button');
button.textContent = "Click me";
document.body.appendChild(button);
function handleClick() {
    console.log("Button clicked");
}
button.addEventListener('click', handleClick);
// لو مش محتاج ال button او ال event listener بعد كده
// لازم اشيل ال event listener عشان ما يحصلش memory leak
button.removeEventListener('click', handleClick);
document.body.removeChild(button);

// 3- setInterval
// لانها بتفضل في الذاكرة طول ما البرنامج شغال
// وبتشتغل عن طريق تتبع الكائنات اللي مش في استخدامها anymore
// وازالتها من الذاكرة
// مثال
setInterval(() => {
    console.log("Interval running");
}, 1000)
// لو مش محتاج ال interval بعد كده
// لازم اشيل ال interval عشان ما يحصلش memory leak
clearInterval();

// 4- اتجنب المصفوفات الكبيرة
// لانها بتفضل في الذاكرة طول ما البرنامج شغال
// وبتشتغل عن طريق تتبع الكائنات اللي مش في استخدامها anymore
// وازالتها من الذاكرة

// 5- اتجنب الاستدعاءات الذاتية بدون شرط انهاء
// لانها بتنشئ مراجع جديدة في الذاكرة بشكل مستمر
// وبتمنع ال garbage collector من ازالتهم من الذاكرة
// وده بيؤدي الي استهلاك زائد للذاكرة وبيسبب بطء في الاداء

// 6- استخدم أدوات تحليل الذاكرة
// زي Chrome DevTools عشان اكتشف ال memory leaks في البرنامج بتاعي
// واصححها بسرعة قبل ما تسبب مشاكل في الاداء

// 7- closures
// لازم اتأكد ان ال closures مش بتحتفظ بمراجع غير ضرورية
// لانها بتمنع ال garbage collector من ازالتهم من الذاكرة
// وده بيؤدي الي استهلاك زائد للذاكرة وبيسبب بطء في الاداء
function outer() {
    let largeArray = new Array(1000000).fill(0);
    return function inner() {
        console.log(largeArray);
    }
}
let closureFunc = outer();
// لو مش محتاج ال closure بعد كده
// لازم امسح المرجع بتاعه عشان ما يحصلش memory leak
closureFunc = null;

// ملحوظة اخيرة
// ال garbage collection في جافاسكريبت عملية تلقائية
// وانا كمطور مش محتاج اتدخل فيها بشكل مباشر
// لكن لازم افهم ازاي بتشتغل عشان اقدر اكتب كود فعال
// وازاي اتجنب ال memory leaks اللي ممكن تسبب مشاكل في الاداء   
// وازاي استخدم أدوات تحليل الذاكرة عشان اكتشف ال memory leaks في البرنامج بتاعي واصححها بسرعة قبل ما تسبب مشاكل في الاداء  

// وده هيخليني اكتب برامج جافاسكريبت اكثر كفاءة واعتمادية
// وده هيخلي البرامج بتاعتي تشتغل بشكل اسرع واكتر سلاسة للمستخدمين بتوعي

